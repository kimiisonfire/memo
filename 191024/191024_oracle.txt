191024_oracle


~~~집합연산자 하는중~~~~
집합연산자 쓸때는 ORDER BY는 가장 마지막 쿼리에만 쓸수있음
집합연산자는 첫번째 쿼리에 줬던 컬럼명으로만 출력함
두개가 서로 다른 컬럼을 가지고있으면 첫번째 쿼리에 줬던 컬럼명 아래로
다른 컬럼의 값이 나와범


INTERSECT :: 교집합!
4월에는 참여했고 5월에는 참여하지않은 회원. < 이런것들을 구할때 집합연산자를 쓰지않겠어?

MINUS :: 여집합
--------------------------------------------------집합연산자는 여기까지----------

서브쿼리를 이용한 DML 할거임
서브쿼리 써서 INSERT, UPDATE, DELETE 하는거란말여

서브쿼리를 이용해서 값을 INSERT해줄때는 VALUES 안써! VALUES 다음에 나올 괄호도 안써!
그냥 바로 서브쿼리 써주는거임. 서브쿼리도 괄호로 안묶어줘1!!!!!
INSERT INTO 테이블명[(컬럼 리스트)]  서브쿼리   => 이렇게!


테이블 내의 자료 삭제 :: DELETE, TRUNCATE

테이블 복사할때 구조와 내용이 복사되지만 기본키와 외래키는 복사 불가능!!!
복사하면 값은 전부 가져와지는데 기본키랑 외래키는 내용은 있지만 제약조건이 없이 넘어옴
전부 일반항목으로 오는거임
-----> 테스트 검증하려고할떄 원본테이블은 그대로두고 DELETE, UPDATE 수행해보기위해 
	구조와 내용만 복사해와서 종종 쓴다고 하네요


DELETE는 ROLLBACK이 됩니다
TRUNCATE는 내용이 삭제되고 ROLLBACK이 안됩니다..! 테이블의 형태만 남아있음,,
DROP하면 테이블 자체가 삭제되고요

DELETE FROM REMAIN1;
COMMIT;
ROLLBACK; 		=>>> 이렇게 세개를 쓰면 TRUNCATE한거나 마찬가지

CREATE, DROP, TRUNCATE는 ROLLBACK의 대상이 아니여1!!!!

------------------할튼 테이블 객체에 대한 얘기는 여기ㄲ지임다.


VIEW 해볼게여

얘는 테이블이랑 똑같이 사용할수있음
그럼 VIEW만쓰지 테이블을 왜쓰죠?  ::  테이블이 없으면 VIEW를 만들수가 없는걸..

VIEW 사용 목적
  - 여러 테이블에 나누어져있는 한군데로 모으려면 원래 서브쿼리를 엄청 여러개쓰잖아
    아주 복잡한 쿼리를 실행시켜 나온결과를 자주사용해야하는 경우엔
    사용할때마다 복잡한 쿼리를 매번 실행시키느니 그 결과를 테이블처럼 쓰면
    JOIN이나 쿼리에 들어가는 시간을 확 줄일수있다구

  - 컬럼수도 엄청많고 행이 엄청긴 테이블을 쓴다고했을때
     내가 그중에서 세네개정도만 쓴다면 전체 테이블에서 일부만 가져와 처리하고 반납하고 
    이렇게하면 시간이 개많이걸린다구..
    나한테 필요한만큼만 뷰로 만들어놓고 일부분만 쓸수있다구

  - 특정테이블에 대해서 접근을 제한할수있음
    테이블중에 특정부분만 필요로한다면 그것만 떼서 줄수가있다구

VIEW는 SELECT의 결과로 나오는 테이블이라면
CURSOR는 SELECT, UPDATE로 영향을 받은 애들... 무튼 VIEW보다 더 큰개념

CREATE [OR REPLACE] VIEW 뷰이름 [(컬럼1, 컬럼2,...)]  
AS
  서브쿼리;
  [WITH CHECK OPTION [CONSTRAINT 제약명]];
  [WITH READ ONLY];

--> 뷰이름 다음에 컬럼명을 안써주면 서브쿼리에서 가져오는 테이블의 컬럼명을 그대로 씀!
--> WITH CHECK OPTION 은 "서브쿼리에서 준 조건문"의 상태를 위배하는 UPDATE가 
	적용할수없음. VIEW를 만든 다음에말여
--> WITH READ ONLY 는 읽기전용 VIEW임. 저게 있으면 VIEW를 건들때 원본자료가 건들여짐







