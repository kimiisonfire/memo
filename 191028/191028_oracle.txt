191028_oracle


인덱스으으으으응으으


인덱스를 만드는 목적 :: 데이터 검색의 효율성을 증가시키려고

장점 :: INSERT, UPDATE, SELECT 처리할때 처리 효율이 올라감 
         인덱스 파일을 이용해서 데이터를 찾아내기때문에, DBMS를 이용해서 데이터를 하나씩 비교하는
	것보다 수월해지거든
단점 :: 수정, 삽입, 삭제가 빈번하게 일어나는 경우에는 인덱스파일을 만들고 구성시키는데 시간이 
	개많이들어서 그럴땐 비효율적임.. 그럴땐 효과가 반감이되죵

인덱스 종류는 그렇게 중요하진 않다네용 보통 NORMAL INDEX니까


보통 인덱스의 객체명은 IDX_ 로 시작합니듀
CREATE [UNIQUE|BITMAP] INDEX 객체명
  ON 테이블명(컬럼명[,..]) [ASC|DESC]
--> UNIQUE, BITMAP 옵션 안쓰면 NORMAL형식이 됩니듀 

컬럼 여러개를 가지고도 하나의 인덱스를 만들수있거든
근데 두개를 가지고 만든 인덱스를 가지고 나중에 WHERE에서 찾을때 
두개의 컬럼을 기준으로 저장된 주소를 인덱스가 가지고있어서
WHERE절에서 하나의 컬럼을 기준으로 조건을주면 인덱스를 만든 의미가 없음
인덱스의 기능을 최대한 쓸수가없는거임
그니까 여러개의 복합 컬럼으로 만들어진 인덱스는
꼭 사용된 컬럼을 전부 조건에 넣어줘라


인덱스를 만들고 걔를 써서 검색하면 검색시간이 차이가난대 크기가 큰 데이터에서는 특히
자주쓰는 컬럼은 인덱스를 만들어놓는게 필요함
회원테이블처럼 자주 변하지않는 테이블은 큰 무리가없지만
내용이 자주 바뀌는 테이블이나 컬럼은 인덱스를 만들면 인덱스 기능을 100% 활용할수없어


인덱스를 만들때 컬럼에 어떤 함수를 줘서 만든경우
CREATE INDEX IDX_MEM_REGNO1 ON MEMBER(SUBSTR(MEM_REGNO1,1,2))  이렇게 했으면
나중에 검색할때도 SUBSTR(MEM_REGNO1,1,2)  얘를 가지고 WHERE절에서 검색해야졍


자료가 변동되면 인덱스가 바로 재구성되냐? 아뇨!
어느정도 시간이 걸림
그래서 시스템이 재구성하기전에 사용자가 강제로 재구성할수있음
==> REBUILD!

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>>> PL/SQL <<<
Procedure Language

그동안 하던거 표준sql은  제어명령도없고 변수도없고 그랬음다
pl/sql은 표준sql에서 기능이 확장된거라
아직 얘에대한 표준 문법이 정의되지않았음. 표준룰이 없어
각 dbms사에서 지네들한테 맞는 가장 좋은 어쩌고를 제안하고있어서
사용하는 dbms가 바뀌면 사용하는 옵션들이 바뀐대;;;;;;; 다시배워야됨;;;;;

PL/SQL은 BLOCK 구조가 기본이고 이걸 응용한것들이 PL/SQL에 포함되는 객체들임

패키지/ 프로시저/ 함수/ 트리거 
변수, 매개변수, 커서, 분기문, 반복구조가 지원 (변수는 물론 지역변수임. 전역변수 없어)

종류 :: 
Anonymous Block(익명블럭)
Stored Procedure(프로시저)
Function, Package, Trigger

cart 테이블에 매출 자료를 insert했어 근데 얘만 업데이트해야되냐? 아니져
재고수불테이블도 업데이트해야되지않겠어??
데이터를 매입했다면 buyprod만 insert하고 끝나는게아니라
insert한후에 해당 자료를 재고수불테이블도 업데이트해야된다구
이걸 사용자가 하면 까먹을수가있어
그래서 insert/delete/update 즉 이벤트가 발생했을떄
이벤트 이후 처리되어져야할 sql들을 정리해놔서 자동으로 처리될수있도록 하는거 = trigger

이거 사용하고싶으면 보기-> DBMS출력-> +눌러서 접속해야 실행 메세지가 뜸


변수에 이름을 부여할때는 Variable   --> V_ 로 시작하는게 일반적
매개변수에 이름을 부여 Parameter --> P_ 로 시작하는게 일반적

변수를 선언만하고 초기화하지않을경우, 숫자/문자 상관없이 변수에는 NULL이 들어감


예) 문자변수에 'My First PL/SQL'을 저장한 후 출력하는 익명 블록을 작성하시오
DECLARE 
  V_TEMP VARCHAR2(50); -- := 'My First PL/SQL';  -> 여기서 초기화해도됨
BEGIN
  V_TEMP := 'My First PL/SQL';
  DBMS_OUTPUT.PUT_LINE(V_TEMP);	--> println()같은거임
END;


pl/sql에서는 하나의 레코드를 하나의 변수로 설정할수있음 참조형으로!
설정해놓고 변수명.컬럼명 이런식으로 쓸수있음
더 크게 테이블 자체를 변수로 선언할수있음

익명블록의 끝은 반드시 / 를 써야된다 << 라고 써있는 책도 있음
developer같은경우는 ctrl+enter, 아니면 실행버튼이 있어서 상관없는데
다른 sql+ 이런거는 실행을 강제하는 / 가 반드시 있어야된대
우리는 필요없음

DBMS 출력창은 새로 실행하면 그 밑으로 작성됨
그니까 하기전에 지우개로 지우는 습관을 들이세용


프롬프트 
ACCEPT 변수명 PROMPT '출력할 메세지'    -> 세미콜론 쓰지않음
이렇게해주면 프롬프트로 받은 값이 변수명에 저장됨
프롬프트로 받았던 변수를 어떤 변수에 저장해주고싶으면
V_TEMPID := '&P_MEMID' ;    이렇게!!!!

declare할때 어떤 테이블의 어떤 컬럼값의 타입을 쓰고싶을때
V_ID MEMBER.MEM_ID%TYPE;   해주면 저 컬럼의 타입을 참조하겠다~ 가됨

BEGIN문에서 SELECT 쓸수있음!!!

EXCEPTION을 자바처럼 쓸수있음
EXCEPTION 할때 특정 클래스를 지정하지않고 그냥 EXCEPTION E 하는것처럼 하고싶으면
WHEN OTHERS THEN   써주면 됨!!!
그리고 SQL 에러메세지를 갖는 객체인 SQLERRM 을 뽑아주면 됨니듀



SCLAR 변수 :: 걍 일반적인 변수
참조형 변수 :: 해당 테이블의 행이나 컬럼의 데이터 타입과 크기를 참조. 
	데이터 자체나 타입을 쓸수있는겨
COMPOSITE :: 배열을 선언할수있다. 레코드타입 = 행 참조, TABLE 타입 = 테이블 전체 참조
BINDING 변수:: 

COMPILER, INTERPRETOR 구분해봐라! 하면
컴파일러 언어 : BINDING 타임이 컴파일시 일어나는.........
인터프레터 언어 : BINDING 타임이 런타임에 일어나는..
기억장소가 마련되고 기억장소에 초기값이 배정되잖아.
그런거가 컴파일할떄 수행되는거는 컴파일러 언어야.
실행됐을때 수행되는거는 인터프리터 언어.
자바, 비주얼베이직 전부 컴파일+인터프리터 언어
인터프리터언어 = 느리지만 융통성이있음
컴파일언어 = 개빨라

프로시저 == 자바의 VOID METHOD
함수 == 반환값이 있는 METHOD 같은거임
이렇게 매개변수/반환값으로 사용되는 변수..! == 바인딩 변수


난수발생시키고싶을때는   DBMS_RANDOM.VALUE(초기값,최종값)
실제로 
V_DEPT_ID := TRUNC(DBMS_RANDOM.VALUE(10,120), -1); 
이렇게 쓸수있겠쥬

쭉 뽑혀나온 뷰에서 다시 하나를 고르고싶다! 하는 의사컬럼을 써서
SELECT문의 첫번쨰 행만 사용할수있음

SELECT EMPLOYEE_ID, EMP_NAME, SALARY 
          INTO V_ID, V_NAME, V_SALARY
    FROM EMPLOYEES
   WHERE DEPARTMENT_ID = V_DEPT_ID
     AND ROWNUM=1;  
======> 이렇게하면 임의의 부서를 SELECT한 결과에서 첫번쨰 행의 사원정보출력


BEGIN에 IF문 쓸수있음
 IF 조건 THEN
   처리문;
 ELSIF 조건 THEN
   처리문;
     :
 ELSE
   처리문;
 END IF;
---------->>>> 이렇게!  ELSE IF 아니고 ELSIF   E 없다!!! ELSIF!!!!!!
처리문마다 꼭 ; 붙여라!!!!!!   다끝나면 END IF 꼭 써줘라!!!!!!!!!!!!!!!!!!!!!!!!!!











