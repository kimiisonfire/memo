191015_oracle

any, some은 앞에 부등호, 등호 등 관계연산자 꼭 쒀줘야댐
mem_id in ('a101', 'a102', 'a103')
mem_id = any ('a101', 'a102', 'a103')
mem_id = some ('a101', 'a102', 'a103') 

exist 는 나중에 서브쿼리할때 배울거임
뒤에 반드시 서브쿼리가 따라나와야되거든
하나라도 존재하면 전체가 true되는거


BETWEEN 사용 :: CASE WHEN THEN  // WHERE 절  여기밖에없음 
길어지는 조건문을 축약가능
>>> 여기까지가 기초였음

JOIN, 서브쿼리, PL/SQL 을 포함하는 문장을 앞으로 해보겠음
서브쿼리의 차수(=DEPTH)가 3, 4정도로 깊어질수가있음 
JOIN도 개많이 쓸거고요


JOIN!
분산된 자료를 검색하는거임.., 
join을 이런 문법을 가지고 해라! 하는건 있는데
보통 dbms쪽에서 본인들거랑 잘 맞는 방식을 소개시켜주긴함
우리는 두개를 다 알고있어야댐;;;; 왜;;;;;

몇개의 행인지 알아보려면 SELECT COUNT(*) FROM 테이블명;

카터시안 조인 : 스지마세요

>>>> Equi join <<< 
: 내부조인. 조인조건을 부여하고 조건에 맞지않는 자료는 무시해버림
	내부조인 : 조인조건이 맞지않는것들을 무시해버리고 출력
	외부조인 : 조인조건이 맞지않는것들을 null로 표시하고 출력
 EQUI -> EQUAL 연산자(=) 를 쓴다고 해서 EQUI임
일반조건과 조인조건의 순서는 상관없음.
컬럼의 구분이 불명확할때는 별칭을 붙여서 구분해줘야겠지	
소속을 알수없을때는 별칭을 붙여주는게 좋음
그래도 소속을 쓰는 습관을 들이라고하네요,,,,

사원테이블에서 사원명, 부서번호, 부서명을 출력하는 거런건데요
SELECT COUNT(*) FROM EMPLOYEES;   이렇게 뽑은 사원의 수는 107
SELECT EMP.EMP_NAME AS 사원명,
       EMP.DEPARTMENT_ID AS 부서번호,
       DEP.DEPARTMENT_NAME AS 부서명
  FROM EMPLOYEES EMP, DEPARTMENTS DEP
 WHERE EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID;  이렇게뽑으면 행이 106개
왜???? 사장은 부서번호가 NULL 이거든..!
사원테이블에는 부서번호 NULL 이 있고 부서테이블에는 없다
부서테이블 == 부족한쪽에다가 (+) 해주면 >> 외부조인 << 이 돼서
부족한쪽은 NULL처리해서 출력해줌
 WHERE EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID(+);
이렇게!!!!

테이블이 N개면 조인조건은 적어도 N-1개!!

오라클에서는 일반조인이 추가되면 외부조인을 쓸수가없음
이걸 해결하려면
1) ANSI 외부조인을 쓴다
2) 일반조인을 서브쿼리 안에다두고 외부조인만 바깥쪽 쿼리에 기술함


GROUP BY : 기준이 되는 항목값 << 이 사실 맞는말인데 그냥 일반컬럼이여

두개의 테이블을 이용해서 select해줘야하는데 두개를 마땅히 이을게 없으면
걔네를 이을수있는 다른 테이블을 하나 이용해주면됨


ANSI INNER JOIN 사용법도 잘알고계십쇼
우선적으로는 ANSI 포맷으로 작성할줄 알아야된다구














