190827_java

JVM 메모리 구조 알면 C의 포인터 개념을 이해하기 쉽다네요,,

OOP : Object Oriented Programming (객체지향프로그래밍)


객체지향 <-> 절차지향 

Math.random()  :: Math = 클래스, random() = 메서드


신뢰성이 높은 프로그래밍이 가능하다
= 절차적언어는 같은 내용을 여러번 써줘야하니까 코드를 수정할 때 적용하지 않거나 해서 실수가 일어날수있음 근데 객체지향언어는 하나만 수정하면 전부 적용이 되니까 신뢰성이 높읍니다.,,


- 클래스의 선언
[접근제어자] [지정예약어] class 클래스명 [extends 클래스] [implements 인터페이스]{}


이클립스에서 하나의 파일 안에 클래스를 두개 작성하면 컴파일할때 지가 알아서 클래스가 두개 생김!!



클래스에서 멤버변수를 선언하고 그걸 인스턴스 생성하면 기본값으로 초기화함
그니까 클래스에서는 선언만 하면ㄴ 되는거쥬

변수명과 메서드명이 같아도 상관없음, 변수끼리 메서드끼리


클래스변수랑 클래스메서드를 부르려고 다른 메서드에서 클래스명.변수명 
이렇게 부를거임 근데 Tv. 하고 ctrl+space 하면 지금 부를수 있는 애들이 뜨거든 그중에 왼쪽에 삼각형이 비어있는게 변수 차있는게 메서드 s는 스태틱임

클래스명.변수명 을 출력하면 기본값이 출력됨..!!



클래스변수 호출 : 클래스명.변수명
클래스메서드 호출 : 클래스명.메서드명

인스턴스화 진행 과정은 배열이랑 같읍니다 
int[] a = new int[3];	
Tv t = new Tv();	그쵸?

인스턴스화를 한다음에 t. 하면 아까처럼 변수랑 메서드 목록이 뜸
인스턴스 변수나 메서드를 쓸때는 클ㄹ래스랑 다르게 참조변수 이름으로 부름
참조변수.변수명 === >  t.channel 요롷게


* 같은 패키지 안에 같은이름의 클래스를 둘순없음다











 