191025_oracle

CREATE [OR REPLACE] VIEW 뷰이름 [(컬럼1, 컬럼2,...)]   -- 얘를 안쓰면 원본테이블의 컬럼명씀
AS
  서브쿼리;
  [WITH CHECK OPTION [CONSTRAINT 제약명]];   
  [WITH READ ONLY];

 - create or REPLACE  --> REPLACE는 걔가 있으면 덮어쓰기합니듀
 - 서브쿼리에서 만들어진 컬럼명에 대치하는게 컬럼1, 컬럼2임. 
  얘를 생략하면 서브쿼리에서 썼던 컬럼명을 쓰는거고, 얘를 쓰면 이 이름을 쓰는거고
 - CHECK OPTION 추가해서 뷰생성하면 서브쿼리에서 제시한 조건을 위배하는 형식의
   자료를 VIEW에 추가/수정할수 없음
   서브쿼리가 만약에
SELECT MEM_ID,
           MEM_MILEAGE
  FROM MEMBER
 WHERE MEM_MILEAGE>3000    으로 해서 서브쿼리를 넣어줬으면
나중에 INSERT INTO VIEW(MEM_ID, MEM_MILEAGE) 
	VALUES('T101', 5000)   ===> 이값을 넣을수가없는겨
얘를 넣으려고하면 원본 테이블이 수정돼버림...


VIEW를 잘못설계하면 VIEW에서 값을바꿀때 원본테이블도 바뀌어버림...! 미틴

WITH CHECK OPTION을 주면 SELECT문의 WHERE절을 위배하지않는 애는 추가되고
걔는 원본테이블에도 추가됨..! 물론 위배하는애를 넣으려고하면 뷰/원본테이블에 안들어가쥬!
VIEW에서 삭제하면 원본테이블에서도 삭제됨~~!!~!~!


WITH READ ONLY; 해주면 삽입/업데이트/삭제 다안됨!! 읽기 전용이니까여
검토용, 조회용으로 확인할때는 READ ONLY를 붙여서 뷰를 만들겠죠


우리가 쓰고있는 표준SQL에서는 반복문 쓸수도없고 커서 쓸수없다네요
그래서 명시적커서를 만들고 하나씩 ITERATOR로 쓰는것처럼 쓸수있는 방법을
나중에 PL/SQL에 가면 공부할거임~~


~~~~~~~~SEQUENCE

SEQUENCE 객체를 만들면 값을 1 늘렸을떄 뒤로 돌아갈수없음!!
그래서 각 테이블이 자기를 담당하는 시퀀스를 별도로 만들어야해
그래서 보통 다수으 ㅣ객체가 하나의 시퀀스를 공유하는건 아주아주 희귀하다구

시퀀스는 2개의 의사 컬럼을 가짐
NEXTVAL, CURRVAL
시퀀스 객체를 만들었으면 반드시 한번은 NEXTVAL을 해줘야됨!!! 그래야 시동이 걸리는거임


~~~~~~~~~SYNONYM (동의어)
객체에 부여하는 별칭!
오라클이 동작하고 있는 동안에는 해당 객체를 얼마든지 호출해서 쓸수있는거임
쿼리 밖에서도..!!
EMPLOYEES, DEPARTMENT 이런거 너무길잖아 얘네한테 별칭을 줘버리는거임

CREATE OR REPLACE SYNONYM DEP FOR DEPARTMENTS;
CREATE OR REPLACE SYNONYM EMP FOR EMPLOYEES;

이렇게 주면 계속 이걸 쓸수가 있는겅임!!!


~~~~~~~~~~INDEX
데이터의 주소가 인덱스에 저장이됩니다..,
그래서 WHERE 어쩌고 할때 전체데이터에서 뒤지는게아니고
인덱스파일에서 먼저찾아보는거임
어떤 컬럼이 인덱스로 저장되면 
그컬럼은 같은 행의 본인을 제외한 데이터의 주소를 담고있읍니다

그럼 전체컬럼을 인덱스로 만들면 개빠르지않을까요?
--> 인덱스가 만들어질때 적용되는 알고리즘이 BTree(네?)라서
     인덱스파일을 최신의 상태로 계속 재구성하는데 시간이 많이걸린다네요.. 중요한가요?

그럼 인덱스는 몇개를 만들어야하죠?
--> 적당히... 예... 
테이블 구성요소에 따라서 왠만하면 변경되지않는 컬럼을 인덱스로 주는ㄱ ㅔ좋겠죠
카트테이블의 변화무쌍한 데이터를 인덱스로만들면
인덱스를 재구성하는데 시간이 훨배많이소요된다고하내요

인덱스 만드는 알고리즘은 이런거 쓰인다~ 정도만... 
회사마다 특정알고리즘을 쓴다네요...


























