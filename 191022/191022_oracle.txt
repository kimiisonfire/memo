191022_oracle

서브쿼리는 반드시 독립적으로 실행되어야함
서브쿼리 부터 실행되니까 바깥쪽에 기술된 테이블의 요소들은 당연히 갖다쓸수가 없어!

서브쿼리로 WHERE절에서 연산을 할때
출력되어지는 열의 개수는 연산자의 좌측을 보세요
하나의 컬럼이다 그러면 연산자 우측의 서브쿼리도 하나의 컬럼만 가져야져
왼쪽에 PAIR가 있으면 그거에 맞게 서브쿼리도 반환해줘야댐
단일행 서브쿼리라해도 행만 하나일뿐 열은 여러개가 나올수있다!

다중행 서브쿼리 연산자중에 ANY, SOME은 앞에 관계연산자가 꼭 나와줘야댐
컬럼명 = ANY|SOME 어쩌구
컬럼명 IN 어쩌구

EXISTS는 서브쿼리의 결과가 하나도 없으면! 리턴되는 값이 한 행도 존재하지 않으면 FALSE
단 한행이라도 존재하면 TRUE임
SELECT절에 어떤 컬럼이 와도 상관이 없어서 컬럼명대신에 숫자 1을 써주고 그럽디다
데이터가 반환되는지 안되는지만 확인하는거임
EXISTS는 반드시1!!! 반드시 뒤에 서브쿼리가 와야댐
IN, ANY, SOME, ALL은 서브쿼리 아니여도댐
EXISTS는 쓸때 보통
WHERE EXISTS (서브쿼리~~)  이렇게 씁니다


단일행 서브쿼리 :: 서브쿼리를 통해서 도출되는 행이 하나인거임
그니까 서브쿼리로 나온 값이 걍 하나의 어떤 값..! 이어야하는거임
써주는 연산자가 단일행 서브쿼리 연산자일경우(=,<,>,<=,>=,<>)
컴파일러가 자동으로 아! 이 뒤에 나오는 것은 단일행 서브쿼리겠구나! 생각해서
서브쿼리문을 실행한 결과가 한줄 이상일경우에는 에러내버림
결과가 여러줄인 서브쿼리면 다중행 서브쿼리연산자 in, any, some, all, exists 써주면댐


테이블에 별칭을 줬을때 어느 한테이블에만 고유하게 있는 컬럼은 
별칭을 안붙여도 상관없지만
그래도 이 컬럼이 어디 소속인지 알려주면 좋으니까 걍 붙이세요


다중행-단일행은 서브쿼리 수행 결과<< 에 대한거지 메인쿼리 수행결과랑 관련X


VIEW : 쿼리 결과의 집합 . FROM절에 사용되는 서브쿼리. 커서의 대상.. 가상의 테이블!
FROM절에 위치하는 서브쿼리는 INLINE VIEW가 되어서 걔를 테이블처럼 간주해서 사용함
VIEW는 보안상 원본데이터를 감추고 사용자에게 필요한부분만 보여주는거임

VIEW는 SELECT문에 의해 도출된 결과의 집합
커서 는 쿼리(SELECT, UPDATE, DELETE,,,)가 실행되면 그거에 영향받는 행들의 집합
커서는 쿼리실행결과의 첫줄이 뜨자마자 오픈되고 결과집합이 끝나면 닫힘
그래서 중간에 들어갈 방법이 없어 = DEFAULT CURSOR
이 전체 집합에 이름을 부여하게되면 커서가 생성되는거임.
그러면 이안에 들어가서 비교/변경을 할수가있어
포인터가 하나씩 차례대로 위에서부터 맨아래까지 지칭을 하는거임. 얘를 데려오세용 이렇게
얘의 위치값을 가리키는거 = 포인터
ITERATOR랑 똑같습니다
딱 실행되면 커서의 위치는 맨 처음으로 가있고 하나씩 아래로 내려가내려가하는거임
STANDARD QUERY에는 커서가 업고요
나중에 PL/SQL에 가면 커서를 쓸거임    / /  커서 지금은 생각하지마세요 (네?)


인라인 :: 
원하는 위치에 함수를 호출하는 대신에(메서드를 호출하는 대신에)
함수의 BODY가 카피돼서 들어감 (메서드 내용을 걍 써버리는거임)
어디서 호출해오는거없이 하나로 싹 카피해와서 하는게 인라인이라네요
외부에서 참조해오는거없이 지혼자 전부 실행가능해야되는거임




















