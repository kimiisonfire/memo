190910_java


Product p = new Product();
Vector item = new Vector();
item.add(p);
>>>>> 여기서 item 에 담긴 p의 price를 보고싶다! 하면
item.get(0).price 이렇게하면 될거같자나
근데 item은 제네릭 Object라서 거기에 있는 Product 타입을 찾을수없음
(Product)item.get(0).price 하면 될거같자나
근데 단항연산자(캐스팅)보다도 . 이 우선순위임
캐스팅되기전에 item에서 price를 찾으러 내려가니 없는거임
그래서 Product p = (Product)item.get(i); 해야 p.price 할수있는거임




프로젝트에서는 이 영수증을 pdf로 아름답게 뽑아내면 됨

1. 주석달아서 뭘할지 틀짜는거		: 분석/설계
2. 실제로 채워넣기 = 개발		: 구현
3. 일부러 터지게 만들면서 테스트하기	: test


프로젝트 : 분석/설계, 구현, 테스트
분석설계단계에서 패키지구성, 클래스, 인터페이스, 화면정의단까지 다만들어짐
선언부까지 다 만들어놓는거임





부모클래스에서 공통의 항목으로 포함되긴하지만 그걸 실행하는 방식이 자식마다 다를떄 => 추상메서드 ㄷ만들어줍니다


alt+shift+s + s : toString() 메서드를 포함하는 필드와 메서드 
	    + v : 오버라이드나 임플리먼트할 메서드 선택



인터페이스는 파일타입도 interface니까 당연히 ctl+n -> interface


인터페이스는 클래스를 상속받을수 없음. 클래스에는 당연히 구현된 메서드가 있을테니까..! 오로지 인터페이스만 상속받을수있음

그리고 메서드에는 구현부가 없으니까 뭘 받아도 상관이없음 = 다중상속

인터페이스는 지들끼리 객체를 만들수가없음. 왜냐면 생성자도 메서드니까..! 그 역할을 해주는 중간다리 클래스가 있어야함.

current~는 현재를 뜻할때 많이 씀
인터페이스는 이름 붙일때 앞에 대문자 I(i)를 붙이기도함



인터페이스의 참조변수로 그를 구현한 구현체의 인스턴스를 참조할 수 있다.
참조변수의 타입에 영향을 받기때문에 인터페이스의 멤버만을 사용할수있음

인터페이스의 다형성은 싱글톤에 필수적입니다..!
---->
컨트롤러 -(인터페이스)- 서비스 -(인터페이스)- dao  
인터페이스 1을 구현하는게 서비스, 인터페이스2를 구현하는게 dao 



인터페이스는 두사람이 작업한다 하면 그냥 두개로 잘라서 각자 구현부를 만들고 나중에 합칠수가 있다..!





jdk1.8은 인터페이스가 일반메서드도 가지고있음. 그리고 그걸 쓸땐 default라고 써줘야돼..
근데 일반메서드가 있으니까 다중상속이 안돼버리는거임..
다중상속할때 똑같은 메서드가 있을경우 구현하는쪽에서 신경써줘야된다는 개그지같은 규칙을 만들어놨대... 
그래서 그냥 1.8에서도 1.7의 방식을 쓰고있음. 1.7만 알고있으면 일하는데 문제가 전혀 없다는거임



익명클래스..!




















