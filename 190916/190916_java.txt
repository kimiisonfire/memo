190916_java


왼쪽 프로젝트칸에 JRE System Library에보면 rt.jar / java.lang 
여기있는것들중에 중요한거 몇개를 배워볼것입니다..

java.lang 패키지에 있는것들은 import 없이 쓸수있음
가장 기본적인것들이라서말여.  system, int, ... 이런것들
lang = language


equals는 사실 == 이랑 같은거긴함..
얘는 주소를 비교하는거잖아 근데 이걸 값 비교로 쓰려고 오버라이드해서씀
이미 equals()를 오버라이드해서 쓰는 것들이 있음..
예를들면 String끼리 equals 비교할때는 실제로 주소를 비교하는게 아니고
걍 값을 비교해서 출력하자나여..


wrapper클래스는 기본형을 객체형태로 사용할수있게 해주는 그런것...

hashCode가 같다 = 주소가 같다


clone
복사하면 안에 담은 내용은 다르지만 파일은 다르잖아
그것처럼 인스턴스를 새로 생성하는건데
변수가 가지고있는 값만 가져간다고 생각하면됨
인스턴스는 복사해가도 별 의미 없으니께
클래스변수는 복사안해도되니까
인스턴스<< 변수의 값<<<< 만 복사함
값만 복사하는거임 인스턴스를 복사해도 인스턴스안의 값만 복사하는거임(기본형


이거 쓰려면 클래스같은경우에는 Cloneable 인터페이스를 임플리먼트해야됨
clone은 protected라서 그냥 가져올수없고 저 인터페이스가 있어야되거든


배열을 clone하려면 임플리먼트필요없고요일단(자바거니까)
그냥 바로 배열을 복사해주면됨
Point[] p = {new Point(1, 1), new Point(2, 2)};
Point[] pCopy = p.clone();

배열은 clone하면 원래거가 값이 바뀌면 복제본도 값이 바뀐다...!
객체를 복사할때의 문제점이 바로 이거임..

배열을 복사하면 배열 var[]을 복사해오면서 
걔가 담고있는 var[0]번째의 주소< 이걸 복사해와버리는거임
그래서 복사해온다음에 원래값을 바꾸면 공유하고있는 값이 바뀌니까 적용돼버림

---> 그래서 이걸 shallow copy 얕은복사라고 합니다
우린 이제 deepcopy를 할거임



응용프로그래밍쪽 갈거면 clone은 필수래..



Class라는 클래스가 있음 클래스의 정보를 얻어오는 클래스임..



우리는 equals, toString 일단 알고있으면 됩니다



문자열을 합칠때 a + "b" 이렇게하는건 매우 효율이 떨어진대.
이걸 할때마다 새로운 인스턴스가 생성되거든


원래 jvm에서 클래스 올리면 메서드영역에 클래스친구들을 올리잖아
근데 사실 그거하면서 클래스 전체의 문자열 String 형 리터럴을 다 찾음..
뭐 메서드안이고 뭐고 다찾으러감
찾아서 문자열을 들고있는 주소를 힙영역에 만들어범...
String str1 = "abc"
String str2 = "abc"
String str3 = "abcd"
--> abc의 주소 :: "abc"
--> abc의 주소 :: 있음
--> abcd의 주소 : "abcd"
=========================> 같은 문자는 같은 주소를 가짐!!!!



주소를 비교하려고 equals를 찍었는데 값이 비교돼서 나온다?
그럼 equals가 어떻게 오버라이드가 된거임..
















